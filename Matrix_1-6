class matrix:
    def __init__(self, rows, cols, data=None):
        # initialize rows and columns
        # if rows or cols are less than or equal to 0, raise an error
        # if data is not given, create a zero matrix with given rows and columns
        if rows <= 0 or cols <= 0:
            raise valueerror("rows and columns must be greater than zero")
        self.rows = rows
        self.cols = cols
        self.data = data if data else [[0] * cols for _ in range(rows)]

    def print(self):
        # print each row of the matrix
        for row in self.data:
            print(row)
        print()

    def plus(self, alice):
        # add two matrices element-wise
        # check if both matrices have the same dimensions
        if self.rows != alice.rows or self.cols != alice.cols:
            raise valueerror("matrices must have the same dimensions to add")
        # return a new matrix with element-wise addition
        return matrix(self.rows, self.cols, [[self.data[i][j] + alice.data[i][j] for j in range(self.cols)] for i in range(self.rows)])

    def times(self, alice):
        # multiply two matrices
        # check if number of columns in first matrix matches number of rows in second matrix
        if self.cols != alice.rows:
            raise valueerror("number of columns of first matrix must equal number of rows of second matrix")
        # calculate result by multiplying corresponding elements and summing them up
        result = [[sum(self.data[i][k] * alice.data[k][j] for k in range(self.cols)) for j in range(alice.cols)] for i in range(self.rows)]
        # return the result as a new matrix
        return matrix(self.rows, alice.cols, result)

    def scalartimesrow(self, scalar, rownumber):
        # multiply a row by a scalar
        # update each element of the row by multiplying it with the scalar
        self.data[rownumber] = [scalar * x for x in self.data[rownumber]]

    def switchrows(self, firstrow, secondrow):
        # switch two rows
        # swap the rows using tuple unpacking
        self.data[firstrow], self.data[secondrow] = self.data[secondrow], self.data[firstrow]

    def linearcombrows(self, scalar, firstrow, secondrow):
        # add scalar times first row to second row
        # update the target row by adding scalar multiple of the source row
        self.data[secondrow] = [self.data[secondrow][j] + scalar * self.data[firstrow][j] for j in range(self.cols)]

    def rowreduce(self):
        # perform row reduction to get row echelon form
        # iterate through each row and column to create pivots
        for i in range(min(self.rows, self.cols)):
            # make the diagonal element 1 by scaling the row
            if self.data[i][i] != 0:
                self.scalartimesrow(1 / self.data[i][i], i)
            # make elements below the pivot equal to 0
            for j in range(i + 1, self.rows):
                if self.data[j][i] != 0:
                    self.linearcombrows(-self.data[j][i], i, j)

    def invert(self):
        # invert the matrix using row reduction
        # only square matrices can be inverted
        if self.rows != self.cols:
            raise valueerror("only square matrices can be inverted")
        # create an identity matrix of the same size
        identity = matrix(self.rows, self.cols, [[1 if i == j else 0 for j in range(self.cols)] for i in range(self.rows)])
        # augment the original matrix with the identity matrix
        augmented = matrix(self.rows, self.cols * 2, [self.data[i] + identity.data[i] for i in range(self.rows)])
        # perform row reduction on the augmented matrix
        augmented.rowreduce()
        # extract the inverse from the augmented matrix
        return matrix(self.rows, self.cols, [augmented.data[i][self.cols:] for i in range(self.rows)])

if __name__ == "__main__":
    while true:
        try:
            # get number of rows and columns from user
            rows = int(input("enter rows: "))
            cols = int(input("enter cols: "))
            # rows and columns must be greater than zero
            if rows <= 0 or cols <= 0:
                print("rows and columns must be greater than zero. please try again.")
                continue
            break
        except valueerror:
            # handle invalid input (non-integer values)
            print("invalid input. please enter valid integers for rows and columns.")

    data = []
    for i in range(rows):
        while true:
            try:
                # get each row of the matrix from user
                row = list(map(float, input(f"row {i + 1}: ").split()))
                # each row must have the same number of columns
                if len(row) != cols:
                    print(f"each row must have exactly {cols} values. please try again.")
                    continue
                data.append(row)
                break
            except valueerror:
                # handle invalid input (non-numeric values)
                print("invalid input. please enter numeric values only.")

    # create the matrix with given data
    trixie = matrix(rows, cols, data)

    while true:
        # display menu of choices
        print("\n1. print matrix\n2. add matrix\n3. multiply matrix\n4. scalar times row\n5. switch rows\n6. restart\n7. exit")
        choice = input("choice: ")

        if choice == '1':
            # print the matrix
            trixie.print()
        elif choice == '2':
            # add another matrix to trixie
            data2 = []
            for i in range(rows):
                while true:
                    try:
                        # get each row of the second matrix
                        row = list(map(float, input(f"row {i + 1}: ").split()))
                        if len(row) != cols:
                            print(f"each row must have exactly {cols} values. please try again.")
                            continue
                        data2.append(row)
                        break
                    except valueerror:
                        print("invalid input. please enter numeric values only.")
            # create second matrix
            alice = matrix(rows, cols, data2)
            # add matrices and print result
            result = trixie.plus(alice)
            result.print()
        elif choice == '3':
            # multiply trixie by another matrix
            while true:
                try:
                    # get dimensions of second matrix
                    other_rows = int(input("enter rows: "))
                    other_cols = int(input("enter cols: "))
                    # check if multiplication is possible
                    if trixie.cols != other_rows:
                        print("number of columns of the first matrix must equal the number of rows of the second matrix.")
                        continue
                    break
                except valueerror:
                    print("invalid input. please enter valid integers for rows and columns.")

            data2 = []
            for i in range(other_rows):
                while true:
                    try:
                        # get each row of the second matrix
                        row = list(map(float, input(f"row {i + 1}: ").split()))
                        if len(row) != other_cols:
                            print(f"each row must have exactly {other_cols} values. please try again.")
                            continue
                        data2.append(row)
                        break
                    except valueerror:
                        print("invalid input. please enter numeric values only.")
            # create second matrix
            alice = matrix(other_rows, other_cols, data2)
            # multiply matrices and print result
            result = trixie.times(alice)
            result.print()
        elif choice == '4':
            # multiply a row of trixie by a scalar
            while true:
                try:
                    # get row number and scalar value from user
                    row_num = int(input("row: "))
                    scalar = float(input("scalar: "))
                    # check if row number is valid
                    if row_num < 0 or row_num >= rows:
                        print(f"row number must be between 0 and {rows - 1}. please try again.")
                        continue
                    # multiply the row by scalar and print result
                    trixie.scalartimesrow(scalar, row_num)
                    trixie.print()
                    break
                except valueerror:
                    print("invalid input. please enter a valid row number and scalar.")
        elif choice == '5':
            # switch two rows of trixie
            while true:
                try:
                    # get row numbers to switch
                    row1 = int(input("first row: "))
                    row2 = int(input("second row: "))
                    # check if row numbers are valid
                    if row1 < 0 or row1 >= rows or row2 < 0 or row2 >= rows:
                        print(f"row numbers must be between 0 and {rows - 1}. please try again.")
                        continue
                    # switch rows and print result
                    trixie.switchrows(row1, row2)
                    trixie.print()
                    break
                except valueerror:
                    print("invalid input. please enter valid row numbers.")
        elif choice == '6':
            # restart the program
            print("restarting..")
            rows, cols = int(input("enter rows: ")), int(input("enter cols: "))
            data = []
            for i in range(rows):
                while true:
                    try:
                        row = list(map(float, input(f"row {i + 1}: ").split()))
                        if len(row) != cols:
                            print(f"each row must have exactly {cols} values. please try again.")
                            continue
                        data.append(row)
                        break
                    except valueerror:
                        print("invalid input. please enter numeric values only.")
            # create new matrix
            trixie = matrix(rows, cols, data)
        elif choice == '7':
            # exit the program
            break
        else:
            # handle invalid choice
            print("invalid choice.")
